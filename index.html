<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Battle-Slopes</title>

  <!-- Firebase App (core) -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>

<!-- Firebase Realtime Database -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>


  <style>
   * { box-sizing: border-box; font-family: Arial, Helvetica, sans-serif; }
    body { margin:0; min-height:100vh; display:flex; justify-content:center; background:linear-gradient(135deg,#1e3c72,#2a5298); color:white; }
    .container { max-width:800px; width:90%; padding:30px; text-align:center; display: flex; justify-content: center; align-items: center; flex-direction: column;}
    h1 { font-size:3rem; margin-bottom:10px; }
    .subtitle { font-size:1.1rem; margin-bottom:30px; opacity:0.9; }
   .card {
  background: rgba(255,255,255,0.12);
  padding: 30px;
  border-radius: 16px;
  box-shadow: 0 10px 25px rgba(0,0,0,0.3);
  width: 100%;
  max-width: 600px;   /* bigger card */
  margin: 0 auto;
}

    button { width:100%; padding:12px; font-size:1rem; border:none; border-radius:8px; background:#ff9800; color:white; cursor:pointer; margin-top:10px; }
    button:hover { background:#fb8c00; }
    input { width:100%; padding:12px; font-size:1rem; border-radius:8px; border:none; margin-top:15px; }
    .divider { margin:15px 0; font-weight:bold; opacity:0.8; }
    hr { margin:40px 0; border:1px solid rgba(255,255,255,0.2); }
    p { text-align:justify; line-height:1.6; }
    a { color:#ffd54f; text-decoration:none; }
    a:hover { text-decoration:underline; }
    .footer { margin-top:30px; font-size:0.85rem; opacity:0.7; }
    #plane {
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
    }
   /* WIN FLASH EFFECT */
@keyframes winFlash {
  0%   { background-color: rgba(255,255,255,0); }
  25%  { background-color: rgba(255,215,0,0.4); }
  50%  { background-color: rgba(255,255,255,0); }
  75%  { background-color: rgba(255,215,0,0.4); }
  100% { background-color: rgba(255,255,255,0); }
}

.win-flash {
  animation: winFlash 1.2s ease-in-out 3;
}

/* WIN POP EFFECT */
@keyframes winPop {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.05); }
  100% { transform: scale(1); }
}

.win-pop {
  animation: winPop 0.6s ease-in-out 3;
}


@keyframes fall {
  to {
    transform: translateY(110vh) rotate(360deg);
    opacity: 0;
  }
}
.confetti {
  position: fixed;
  top: -10px;
  width: 10px;
  height: 10px;
  z-index: 9999;
  pointer-events: none;
  animation: confettiFall linear forwards;
}

@keyframes confettiFall {
  0% {
    transform: translateY(0) rotate(0deg);
    opacity: 1;
  }
  100% {
    transform: translateY(110vh) rotate(720deg);
    opacity: 0;
  }

#enableSoundIcon {
  position: fixed;
  top: 10px;
  right: 10px;
  font-size: 2rem;
  color: white;
  cursor: pointer;
  z-index: 10; /* Ensure the icon is above other elements */
  transition: color 0.3s ease;
}

#enableSoundIcon:hover {
  color: #ff9800; /* Change color on hover */
}

.notification {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background-color: rgba(255, 0, 0, 0.7);
  color: white;
  padding: 10px;
  border-radius: 5px;
  display: none;  /* Hidden by default */
}

}




.win-animation {
  animation: winFlash 1s ease-in-out 3;
}
  </style>
</head>

<body>

<div class="container">
  <h1>ðŸŽ¯ Battle-Slopes</h1>
  <p class="subtitle" style="text-align: center;">A Two-Player Math Strategy Game<br>Coordinate Geometry â€¢ Slopes â€¢ Logic </p>


  <!-- Lobby -->
  <div class="card" id="lobby">
    <i id="enableSoundIcon" class="fas fa-volume-up" onclick="enableSound()" title="Enable Sound"></i>
    <button onclick="createRoom()">Create Room</button>
    <div class="divider">OR</div>
    <input type="text" id="roomInput" placeholder="Enter Room Code">
    <button onclick="joinRoom()">Join Room</button>
  </div>

  <!-- Game -->
  <div class="card" id="game" style="display:none;">
    <p id="roomCodeDisplay" style="font-size:1.2rem; margin-bottom:10px;">
  Room Code: <b id="roomCodeText"></b>
</p>
    <p id="timerText" style="font-size:1.1rem; font-weight:bold;"></p>
    <p id="statusText">Place your 4 ships</p>
    <svg id="plane" width="400" height="400"></svg>
    <input type="text" id="slopeInput" placeholder="Enter slope formula (e.g. y = mx + b)" style="display:none;">
    <button onclick="attackWithSlope()" id="attackButton" style="display:none;">Attack with slope</button>
    <button onclick="resetGameState()" id="restartBtn" style="display:none;">Restart / Rematch</button>
  </div>

  <hr>

  <p><b>All About Battle-Slopes</b></p>
  <p>
    Battle-Slopes is an interactive two-player game where players plot ships on a Cartesian grid
    and attack by forming linear equations using slope and coordinates.
  </p>

  <p> The project <b>Battle-Slopes</b> is an interactive, two-player, web-based educational game inspired by the classic <a href="https://en.wikipedia.org/wiki/Battleship" target="_blank">Battleship</a>. Players strategically plot ships on a Cartesian plane and attack by forming linear equations using slope and coordinate pairs. </p>

  <p class="footer">Â© 2026 Battle-Slopes | Math Meets Strategy</p>
</div>

<script>
/* ===================== FIREBASE CONFIG ===================== */
const firebaseConfig = {
  apiKey: "AIzaSyAVKLWoek9nvjO2qzUKHwRrMhqpsjaDiG8",
  authDomain: "battle-slopes.firebaseapp.com",
  databaseURL: "https://battle-slopes-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "battle-slopes",
  storageBucket: "battle-slopes.firebasestorage.app",
  messagingSenderId: "328801882779",
  appId: "1:328801882779:web:c2037289a355dd3733ec3e",
  measurementId: "G-0N95P20HTE"
};
firebase.initializeApp(firebaseConfig);
const database = firebase.database();
database.ref(".info/connected").on("value", snap => {
  alert("Firebase connected: " + snap.val());
});

/* ===================== GAME VARIABLES ===================== */
let roomCode = null;
let playerNum;
let myShips = [];
let opponentShips = [];
let turn = 1;
let maxShips = 4;
let status = "placing"; // placing -> battle -> finished
let attackPoints = [];
let turnTimer = null;
let timeLeft = 20;
let roomRef;

/* ===================== ROOM FUNCTIONS ===================== */
function generateRoomCode() {
  return "BS-" + Math.random().toString(36).substr(2,4).toUpperCase();
}

function createRoom() {
  roomCode = generateRoomCode();
  roomRef = database.ref("rooms/" + roomCode); // Assigning roomRef
  playerNum = 1;

  database.ref("rooms/" + roomCode).set({
    player1: { joined:true, ships:[], hits:[], misses:[], usedEquations:[], restartClicked: false },
    player2: { joined:false, ships:[], hits:[], misses:[], usedEquations:[], restartClicked: false },
    turn:1,
    status:"placing"
  });

  document.getElementById("roomCodeText").textContent = roomCode;

  enterGame();
}


function joinRoom() {
  roomCode = document.getElementById("roomInput").value.trim().toUpperCase();
  roomCode = roomCode.replace(/\s+/g, "");

  if (!roomCode) {
    alert("Enter a room code.");
    return;
  }

  const roomRef = database.ref("rooms/" + roomCode);

  roomRef.once("value").then(snapshot => {
    if (!snapshot.exists()) {
      alert("Room does not exist.");
      return;
    }

    const room = snapshot.val();

    // ðŸš« Room full check
    if (room.player2 && room.player2.joined === true) {
      alert("Room is full.");
      return;
    }

    // âœ… Join as Player 2
    playerNum = 2;

    roomRef.update({
      "player2/joined": true
    }).then(() => {
      // âœ… SHOW ROOM CODE ON SCREEN
      document.getElementById("roomCodeText").textContent = roomCode;

      // âœ… ENTER GAME (pregame)
      enterGame();
    });
  });
}

/* ===================== ENTER GAME ===================== */
function enterGame(){
  document.getElementById("lobby").style.display="none";
  document.getElementById("game").style.display="block";
  createGrid();
  listenRoomUpdates();
}

function playWinAnimation() {
  document.body.classList.add("win-flash");
  document.querySelector(".container")?.classList.add("win-pop");

  setTimeout(() => {
    document.body.classList.remove("win-flash");
    document.querySelector(".container")?.classList.remove("win-pop");
  }, 4000);
}


/* ===================== GRID & SHIP PLACEMENT ===================== */
 function createGrid() {
      const svg = document.getElementById("plane");
      svg.innerHTML = "";

      const size = 400;
      const step = 40;
      const center = size / 2;

      svg.setAttribute("width", size);
      svg.setAttribute("height", size);

      // Draw grid lines
      for (let i = 0; i <= size; i += step) {
        svg.innerHTML += `<line x1="${i}" y1="0" x2="${i}" y2="${size}" stroke="rgba(255,255,255,0.3)"/>`;
        svg.innerHTML += `<line x1="0" y1="${i}" x2="${size}" y2="${i}" stroke="rgba(255,255,255,0.3)"/>`;
      }

      // Axes (center line)
      svg.innerHTML += `<line x1="${center}" y1="0" x2="${center}" y2="${size}" stroke="white" stroke-width="2"/>`;
      svg.innerHTML += `<line x1="0" y1="${center}" x2="${size}" y2="${center}" stroke="white" stroke-width="2"/>`;

      // Click detection
      svg.addEventListener("click", (e) => {
        const rect = svg.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - center) / step);
        const y = Math.round((center - (e.clientY - rect.top)) / step);
        handlePlaneClick(x, y);
      });
    }


function handlePlaneClick(x,y){
  if(status !== "placing") return;
  if(myShips.length >= maxShips) return;
  if(myShips.some(s=>s[0]===x && s[1]===y)) return;

  myShips.push([x,y]);
  drawPoint(x,y,"#4caf50");

  database.ref(`rooms/${roomCode}/player${playerNum}/ships`).set(myShips);

  if (myShips.length === maxShips) {
    checkReady(); // ðŸ”¥ THIS WAS MISSING
  }
}


function drawPoint(x,y,color){
  const svg = document.getElementById("plane");
  const center = 200;
  const step = 40;

  const cx = center + x*step;
  const cy = center - y*step;

  svg.innerHTML += `<circle cx="${cx}" cy="${cy}" r="6" fill="${color}"/>`;
}


function handleCellClick(x,y,cell){
  if(status !== "placing") return;

  if(myShips.length < maxShips){
    if(myShips.some(s=>s[0]===x && s[1]===y)) return;
    myShips.push([x,y]);
    cell.classList.add("ship");
    database.ref(`rooms/${roomCode}/player${playerNum}/ships`).set(myShips);
    if(myShips.length === maxShips) checkReady();
  }
}

/* ===================== CHECK READY & START BATTLE ===================== */
function startCountdown(){
  const roomRef = database.ref(`rooms/${roomCode}`);

  const interval = setInterval(()=>{
    roomRef.once("value").then(snapshot=>{
      const room = snapshot.val();
      if(!room || room.status !== "confirming"){
        clearInterval(interval);
        return;
      }

      if(room.countdown <= 0){
        roomRef.update({
          status: "battle",
          countdown: null,
          turn: 1
        });
        clearInterval(interval);
      } else {
        roomRef.update({
          countdown: room.countdown - 1
        });
      }
    });
  }, 1000);
}
function checkReady(){
  const roomRef = database.ref(`rooms/${roomCode}`);

  roomRef.once("value").then(snapshot=>{
    const room = snapshot.val();
    if(!room) return;

    const ready1 = room.player1.ships.length === maxShips;
    const ready2 = room.player2.ships.length === maxShips;

    if(ready1 && ready2 && room.status === "placing"){
      roomRef.update({
        status: "confirming",
        countdown: 10
      });
      startCountdown();
    } else {
      document.getElementById("statusText").textContent =
        "Waiting for opponent to place ships...";
    }
  });
}

function startTurnTimer() {
  if (turnTimer) return;

  timeLeft = 20;
  updateTimerText();

  turnTimer = setInterval(() => {
    timeLeft--;
    updateTimerText();

    if (timeLeft <= 0) {
      clearInterval(turnTimer);
      turnTimer = null;
      forceEndTurn();
    }
  }, 1000);
}


function updateTimerText() {
  document.getElementById("timerText").textContent =
    `â³ Time left: ${timeLeft}s`;
}

function forceEndTurn() {
  alert("â° Time's up! Turn skipped.");

  const roomRef = database.ref(`rooms/${roomCode}`);
  roomRef.once("value").then(snapshot => {
    const room = snapshot.val();
    if (!room || room.status !== "battle") return;

    roomRef.update({
      turn: room.turn === 1 ? 2 : 1
    });
  });
}

function launchConfetti() {
  const colors = ["#ff5252", "#ffeb3b", "#4caf50", "#2196f3", "#e040fb"];

  for (let i = 0; i < 120; i++) {
    const confetti = document.createElement("div");
    confetti.className = "confetti";

    confetti.style.left = Math.random() * 100 + "vw";
    confetti.style.backgroundColor =
      colors[Math.floor(Math.random() * colors.length)];
    confetti.style.animationDuration = (2 + Math.random() * 3) + "s";
    confetti.style.width = confetti.style.height =
      6 + Math.random() * 8 + "px";

    document.body.appendChild(confetti);

    setTimeout(() => confetti.remove(), 5000);
  }
}


/* ===================== LISTEN FOR UPDATES ===================== */
function listenRoomUpdates() {
  const roomRef = database.ref(`rooms/${roomCode}`);
  roomRef.on("value", snapshot => {
    const room = snapshot.val();
    if (!room) return;

    status = room.status;
    turn = room.turn;

    const opponentNum = playerNum === 1 ? 2 : 1;
    opponentShips = room[`player${opponentNum}`].ships || [];

    updateGrid(room);  // Make sure the grid is updated whenever the game state changes
    updateStatusText(room);  // Update the status message
    checkAutoStart(room);  // Check if the game should start automatically
  });
}


function checkAutoStart(room){
  const ready1 = room.player1.ships.length === maxShips;
  const ready2 = room.player2.ships.length === maxShips;

  if(ready1 && ready2 && room.status === "placing"){
    database.ref(`rooms/${roomCode}`).update({
      status: "confirming",
      countdown: 10
    });
    startCountdown();
  }
}


/* ===================== GRID CREATION & CLICK ===================== */
const GRID_SIZE = 400;
const STEP = 40;
const CENTER = GRID_SIZE / 2;
const svg = document.getElementById("plane");

// Create the grid once
function createGrid() {
  svg.innerHTML = "";

  // Draw vertical and horizontal lines
  for (let i = 0; i <= GRID_SIZE; i += STEP) {
    const vLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    vLine.setAttribute("x1", i);
    vLine.setAttribute("y1", 0);
    vLine.setAttribute("x2", i);
    vLine.setAttribute("y2", GRID_SIZE);
    vLine.setAttribute("stroke", "rgba(255,255,255,0.3)");
    svg.appendChild(vLine);

    const hLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
    hLine.setAttribute("x1", 0);
    hLine.setAttribute("y1", i);
    hLine.setAttribute("x2", GRID_SIZE);
    hLine.setAttribute("y2", i);
    hLine.setAttribute("stroke", "rgba(255,255,255,0.3)");
    svg.appendChild(hLine);
  }

  // Draw axes
  const xAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
  xAxis.setAttribute("x1", 0);
  xAxis.setAttribute("y1", CENTER);
  xAxis.setAttribute("x2", GRID_SIZE);
  xAxis.setAttribute("y2", CENTER);
  xAxis.setAttribute("stroke", "white");
  xAxis.setAttribute("stroke-width", 2);
  svg.appendChild(xAxis);

  const yAxis = document.createElementNS("http://www.w3.org/2000/svg", "line");
  yAxis.setAttribute("x1", CENTER);
  yAxis.setAttribute("y1", 0);
  yAxis.setAttribute("x2", CENTER);
  yAxis.setAttribute("y2", GRID_SIZE);
  yAxis.setAttribute("stroke", "white");
  yAxis.setAttribute("stroke-width", 2);
  svg.appendChild(yAxis);

  // Add click listener only once
  if (!svg.dataset.listenerAdded) {
    svg.addEventListener("click", (e) => {
      const rect = svg.getBoundingClientRect();
      const x = Math.round((e.clientX - rect.left - CENTER) / STEP);
      const y = Math.round((CENTER - (e.clientY - rect.top)) / STEP);
      handlePlaneClick(x, y);
    });
    svg.dataset.listenerAdded = "true";
  }
}

/* ===================== UPDATE GRID ===================== */
function updateGrid(room) {
  // Remove only old ships, hits, and misses
  svg.querySelectorAll("circle").forEach(c => c.remove());

  // Draw my ships
  myShips.forEach(([x, y]) => drawPoint(x, y, "#4caf50"));

  // Draw my hits
  const hits = room[`player${playerNum}`]?.hits || [];
  hits.forEach(([x, y]) => drawPoint(x, y, "red"));

  // Draw misses (attacks that didn't hit)
  const misses = room[`player${playerNum}`]?.misses || [];
  misses.forEach(m => {
    if (m[0] === "line") {
      drawAttackLine(m[1], m[2], "#999"); // Optional: gray for misses
    }
  });

  // Draw opponent hits on your ships
  const opponentNum = playerNum === 1 ? 2 : 1;
  const opponentHits = room[`player${opponentNum}`]?.hits || [];
  opponentHits.forEach(([x, y]) => {
    // Only mark if it hit your ship
    if (myShips.some(s => s[0] === x && s[1] === y)) {
      drawPoint(x, y, "orange"); // hit on your ship
    }
  });
}


/* ===================== DRAW POINT ===================== */
function drawPoint(x, y, color) {
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", CENTER + x * STEP);
  circle.setAttribute("cy", CENTER - y * STEP);
  circle.setAttribute("r", 6);
  circle.setAttribute("fill", color);
  svg.appendChild(circle);
}


/* ===================== STATUS TEXT ===================== */
function updateStatusText(room) {
  const statusText = document.getElementById("statusText");
  const slopeInput = document.getElementById("slopeInput");
  const attackButton = document.getElementById("attackButton");
  const restartBtn = document.getElementById("restartBtn");
  const timerText = document.getElementById("timerText");

  // Reset UI first (prevents leftovers)
  slopeInput.style.display = "none";
  attackButton.style.display = "none";
  restartBtn.style.display = "none";

  if (room.status === "placing") {
    statusText.textContent = "Place your 4 ships";
    timerText.textContent = "";
    clearInterval(turnTimer);
    return;
  }

  if (room.status === "confirming") {
    statusText.textContent =
      `Confirming ship placementâ€¦ Game starts in ${room.countdown}s`;
    timerText.textContent = "";
    clearInterval(turnTimer);
    return;
  }

  if (room.status === "battle") {
    if (room.turn === playerNum) {
      statusText.textContent = "ðŸŽ¯ Your turn! Enter a slope to attack.";
      slopeInput.style.display = "block";
      attackButton.style.display = "block";

      // Start timer ONLY if not already running
      if (!turnTimer) startTurnTimer();
    } else {
      statusText.textContent = "â³ Opponent's turn, please waitâ€¦";
      timerText.textContent = "";
      clearInterval(turnTimer);
      turnTimer = null;
    }
    return;
  }

  if (room.status === "finished") {
    clearInterval(turnTimer);
    turnTimer = null;
    timerText.textContent = "";

    if (room.winner === playerNum) {
      statusText.textContent = "ðŸŽ‰ You win!";
    } else {
      statusText.textContent = "ðŸ’¥ You lost! Better luck next time.";
    }

    restartBtn.style.display = "block";
  }
}


/* ===================== ATTACK PHASE - SLOPE FORMULA ===================== */
function attackWithSlope() {
  console.log("Attack button clicked");  // Debugging log

  const formula = document.getElementById("slopeInput").value.trim();
  console.log("Entered formula:", formula);  // Debugging log

  if (status !== "battle") {
    console.log("Not in battle state, returning...");  // Debugging log
    return;
  }

   if (!formula) {
    alert("Please enter a valid slope formula.");
    return;
  }
  // ðŸ”Š Play a neutral click / attack sound immediately
  playSound("turnSound"); // or hitSound placeholder

  const roomRef = database.ref(`rooms/${roomCode}`);
  roomRef.once("value").then(snapshot => {
    const room = snapshot.val();
    const opponentNum = playerNum === 1 ? 2 : 1;

    if (room.turn !== playerNum) {
      alert("It's not your turn!");
      return;
    }

    if (room[`player${opponentNum}`].ships.length < maxShips) {
      alert("Opponent has not finished placing ships.");
      return;
    }

    // Parse the slope formula
    const [slopeMatch, slope, intercept] = parseSlopeFormula(formula);
    console.log("Parsed slope:", slope, "Parsed intercept:", intercept);  // Debugging log

    if (slopeMatch && slope !== undefined) {
      performAttackWithSlope(slope, intercept);
    } else {
      alert("Invalid slope formula! Ensure the formula is in the format 'y = mx + b'.");
    }
  });
}

/* ===================== SLOPE FORMULA PARSER ===================== */
function parseSlopeFormula(formula) {
  formula = formula.replace(/\s+/g, "");

  const match = formula.match(/^y=([+-]?\d*\/?\d*)x([+-]\d+\/?\d*)?$/);

  if (!match) return [false, null, null];

  let m = match[1];
  let b = match[2];

  // slope
  if (m === "" || m === "+") m = 1;
  else if (m === "-") m = -1;
  else m = parseFraction(m);

  // intercept
  b = b ? parseFraction(b) : 0;

  return [true, m, b];
}


// Helper function to parse fractions like "2/3" or whole numbers like "3"
function parseFraction(fraction) {
  // If it's a fraction (e.g., "2/3"), split and divide
  if (fraction.includes("/")) {
    const parts = fraction.split("/").map(num => parseFloat(num.trim()));
    return parts[0] / parts[1];
  }
  
  // If it's a whole number, just return it as a float
  return parseFloat(fraction);
}

const soundPool = {};

function playSound(id) {
  const src = document.getElementById(id)?.querySelector("source")?.src;
  if (!src) return;

  // Create a fresh audio instance every time
  const audio = new Audio(src);
  audio.volume = 1;
  audio.play().catch(() => {});
}


/* ===================== ATTACK WITH SLOPE ===================== */
// In the attack function, only mark the ship as "hit" without removing it from the ships array
function performAttackWithSlope(slope, intercept) {
  const roomRef = database.ref(`rooms/${roomCode}`);
  const opponentNum = playerNum === 1 ? 2 : 1;

  roomRef.once("value").then(snapshot => {
    const room = snapshot.val();
    if (!room || room.status !== "battle") return;

    // ðŸš« Not your turn
    if (room.turn !== playerNum) {
      alert("It's not your turn!");
      return;
    }

    let opponentShips = room[`player${opponentNum}`].ships || [];
    let hits = room[`player${playerNum}`].hits || [];
    let misses = room[`player${playerNum}`].misses || [];
    let usedEquations = room[`player${playerNum}`].usedEquations || [];

    // ðŸ” Normalize equation to prevent duplicates
    const equationKey = `y=${slope.toFixed(4)}x+${intercept.toFixed(4)}`;

    // ðŸš« Reused equation â†’ NO TURN LOSS
    if (usedEquations.includes(equationKey)) {
      alert("âš ï¸ You already used this equation!");
      return;
    }

    usedEquations.push(equationKey);

    let hitCount = 0;
    const tolerance = 0.01;

    // ðŸŽ¯ Visual attack
    clearAttackLine();
    drawAttackLine(slope, intercept);

    // ðŸŽ¯ Hit detection
    opponentShips.forEach(([x, y]) => {
      const expectedY = slope * x + intercept;
      if (Math.abs(y - expectedY) < tolerance) {
        if (!hits.some(h => h[0] === x && h[1] === y)) {
          hits.push([x, y]);
          hitCount++;
        }
      }
    });

    const soundToPlay = hitCount === 0 ? "missSound" : "hitSound";
    playSound(soundToPlay);

    // ðŸ† WIN CHECK
    const totalOpponentShips = opponentShips.length;
    const totalHits = hits.length;

    // ðŸ” Switch turn AFTER valid attack
    const nextTurn = room.turn === 1 ? 2 : 1;

    const updateData = {
      [`player${playerNum}/hits`]: hits,
      [`player${playerNum}/misses`]: misses,
      [`player${playerNum}/usedEquations`]: usedEquations,
      turn: nextTurn
    };

    // ðŸ Game over
    if (totalHits >= totalOpponentShips && totalOpponentShips > 0) {
       playSound("winSound");
      updateData.status = "finished";
      updateData.winner = playerNum;
      updateData.turn = null;

     
      playWinAnimation();
      launchConfetti();
      clearInterval(turnTimer);
      document.getElementById("timerText").textContent = "";


    document.getElementById("statusText").textContent =
  `ðŸŽ‰ You win!`;
    } else {
      playSound("turnSound");
      startTurnTimer();
    }

    roomRef.update(updateData);
  });
}




  /* ===================== DRAW THE ATTACK LINE ===================== */
  function drawAttackLine(slope, intercept, color = "#ff9800") {
  // Clear previous line only when drawing a new one
  const existingLine = svg.querySelector('.attack-line');
  if (existingLine) existingLine.remove();

  const size = 400;
  const step = 40;
  const center = size / 2;

  let path = "";
  const gridMin = -5; // Adjust to cover full grid
  const gridMax = 5;

  for (let x = gridMin; x <= gridMax; x += 0.1) { // smoother line
    const y = slope * x + intercept;

    const svgX = center + x * step;
    const svgY = center - y * step;

    if (x === gridMin) path = `M ${svgX} ${svgY}`;
    else path += ` L ${svgX} ${svgY}`;
  }

  const line = document.createElementNS("http://www.w3.org/2000/svg", "path");
  line.setAttribute("d", path);
  line.setAttribute("stroke", color);
  line.setAttribute("stroke-width", "3");
  line.setAttribute("fill", "none");
  line.setAttribute("class", "attack-line");

  svg.appendChild(line);
}

// Function to register a hit
// Example of how a hit might be registered
function registerHit(playerId, targetPlayerId, targetShipId) {
  // Assuming you have a system where you store the ships and their positions
  const playerShipsRef = roomRef.child(targetPlayerId + '/ships');
  
  playerShipsRef.once('value', snapshot => {
    const ships = snapshot.val();
    
    // Find the ship that was hit by comparing its coordinates with the attack
    const ship = ships.find(ship => ship.id === targetShipId);
    
    if (ship) {
      // Ship is hit, update Firebase with the hit status
      roomRef.child(targetPlayerId).update({
        hitNotification: `Your ${ship.name} has been hit!`
      }).then(() => {
        // Optionally: Notify the player via UI as well
        showHitNotification(targetPlayerId, ship.name);
      });

      // Mark the ship as hit
      roomRef.child(targetPlayerId + '/ships').child(ship.id).update({
        isHit: true
      });

      // You can also update the attacker's record if needed (for tracking)
      roomRef.child(playerId).update({
        lastHit: `You hit ${targetPlayerId}'s ${ship.name}!`
      });
    }
  });
}


// Listen for changes in the hitNotification field for both players
roomRef.on('value', snapshot => {
  const gameData = snapshot.val();
  
  if (gameData.player1.hitNotification) {
    showHitNotification("player1", gameData.player1.hitNotification);
  }

  if (gameData.player2.hitNotification) {
    showHitNotification("player2", gameData.player2.hitNotification);
  }
});

// Function to display the hit notification
function showHitNotification(playerId, message) {
  const notificationElement = document.getElementById(playerId + 'HitNotification');
  if (notificationElement) {
    notificationElement.textContent = message;
    notificationElement.style.display = 'block';  // Show the notification
    setTimeout(() => {
      notificationElement.style.display = 'none';  // Hide it after a few seconds
    }, 5000);  // Hide after 5 seconds
  }
}


  /* ===================== CLEAR ATTACK LINE ===================== */
  function clearAttackLine() {
    const svg = document.getElementById("plane");
    const existingLine = svg.querySelector('.attack-line');
    if (existingLine) {
      existingLine.remove();
    }
  }
/* ===================== RESTART / REMATCH (SELF-CONTAINED) ===================== */

/* SAFE FALLBACK UI FUNCTIONS */
window.resetGrid = window.resetGrid || function () {};
window.resetShipPlacementUI = window.resetShipPlacementUI || function () {};
window.resetHitsAndMissesUI = window.resetHitsAndMissesUI || function () {};

/* INTERNAL STATE */
let restartCountdownStarted = false;
let restartInterval = null;

/* BUTTON HANDLER */
// This function is called when either player clicks the "Restart" button
function handleRestartButtonClick() {
  if (!roomRef || typeof playerNum === "undefined") {
    console.error("RoomRef or PlayerNum not defined!");
    return;
  }

  const playerRef = roomRef.child(`player${playerNum}`);
  
  console.log(`Updating restartClicked for player${playerNum}`);
  // Set the 'restartClicked' to true in the database for the current player
  playerRef.update({
    restartClicked: true
  }).then(() => {
    console.log(`restartClicked set to true for player${playerNum}`);
    // Check if both players have clicked restart
    checkBothPlayersClickedRestart(roomRef);
  }).catch(error => {
    console.error("Error updating restartClicked:", error);
  });
}

/* MAIN LISTENER */
roomRef.on("value", snapshot => {
  const data = snapshot.val();
  if (!data) return;

  /* START COUNTDOWN ONLY ONCE */
  if (
    data.player1?.restartClicked &&
    data.player2?.restartClicked &&
    data.status === "finished" &&
    !restartCountdownStarted
  ) {
    restartCountdownStarted = true;
    startRestartCountdown(roomRef);
  }

  /* COUNTDOWN DISPLAY */
  if (data.status === "countdown") {
    showRestartCountdown(data.restartTimer);
  }

  /* RESET UI AFTER RESTART */
  if (data.status === "placing") {
    restartCountdownStarted = false;
    clearInterval(restartInterval);
    hideRestartCountdown();
    resetGrid();
    resetShipPlacementUI();
    resetHitsAndMissesUI();
  }

  toggleRestartButton(data.status);
});

/* CHECK IF BOTH PLAYERS HAVE CLICKED RESTART */
function checkBothPlayersClickedRestart(roomRef) {
  console.log("Checking if both players have clicked restart...");
  roomRef.once("value", snapshot => {
    const data = snapshot.val();
    if (data) {
      console.log("Snapshot data: ", data);
      if (data.player1.restartClicked && data.player2.restartClicked) {
        console.log("Both players have clicked restart! Starting countdown...");
        startRestartCountdown(roomRef);
      } else {
        console.log("Waiting for both players to click restart.");
      }
    } else {
      console.error("Error: No data found for room.");
    }
  });
}


/* COUNTDOWN LOGIC */
function startRestartCountdown(roomRef) {
  let time = 5; // Countdown duration
  
  // Update the game status to 'countdown' and set the timer
  roomRef.update({
    status: "countdown",
    restartTimer: time
  }).then(() => {
    console.log("Countdown started, time: ", time);  // Debugging log
  }).catch(error => {
    console.error("Error starting countdown:", error);
  });

  // Start countdown interval
  restartInterval = setInterval(() => {
    time--;

    roomRef.update({
      restartTimer: time
    }).catch(error => {
      console.error("Error updating countdown timer:", error);
    });

    if (time <= 0) {
      clearInterval(restartInterval);
      resetGameState(roomRef);
    }
  }, 1000);
}

/* RESET GAME STATE */
function resetGameState(roomRef) {
  console.log("Resetting game state...");

  roomRef.update({
    status: "placing", // Reset game to 'placing' mode for ships
    restartTimer: null, // Clear the restart timer
    turn: 1, // Set player 1's turn
    player1: {
      restartClicked: false, // Reset restartClicked flag
      ships: [], // Clear player 1's ships
      hits: [], // Clear player 1's hits
      misses: [] // Clear player 1's misses
    },
    player2: {
      restartClicked: false, // Reset restartClicked flag
      ships: [], // Clear player 2's ships
      hits: [], // Clear player 2's hits
      misses: [] // Clear player 2's misses
    }
  }).then(() => {
    console.log("Game state reset successful.");
    resetGrid();
    resetShipPlacementUI();
    resetHitsAndMissesUI();
  }).catch(error => {
    console.error("Error resetting game state:", error);
  });

  resetUIForShipPlacement();
}

/* RESET UI FOR SHIP PLACEMENT */
function resetUIForShipPlacement() {
  resetGrid();
  resetShipPlacementUI();
  resetHitsAndMissesUI();

  const gridElement = document.getElementById("gameGrid");
  const restartButton = document.getElementById("restartBtn");

  gridElement.style.display = "block"; // Show the grid
  restartButton.style.display = "none"; // Hide restart button
  showShipPlacementInstructions(); // Show placement instructions
}

function showShipPlacementInstructions() {
  const instructions = document.getElementById("shipPlacementInstructions");
  instructions.style.display = "block"; // Show placement instructions if any
}

/* UI HELPERS */
function showRestartCountdown(time) {
  const el = document.getElementById("countdownDisplay");
  el.style.display = "block";
  el.textContent = `Restarting in ${time}...`;
}

function hideRestartCountdown() {
  const el = document.getElementById("countdownDisplay");
  el.style.display = "none";
  el.textContent = "";
}

function toggleRestartButton(status) {
  const btn = document.getElementById("restartBtn");
  const countdown = document.getElementById("countdownDisplay");

  if (status === "finished") {
    btn.style.display = "block";
    btn.disabled = false;
    countdown.style.display = "none";
  } else if (status === "countdown") {
    btn.style.display = "none";
    countdown.style.display = "block";
  } else {
    btn.style.display = "none";
    countdown.style.display = "none";
  }
}

/* RESET GRID FUNCTION */
function resetGrid() {
  // Create a 10x10 empty grid (or your grid size)
  const grid = [];
  for (let i = 0; i < 10; i++) {
    const row = [];
    for (let j = 0; j < 10; j++) {
      row.push(null); // Empty space (no ship)
    }
    grid.push(row);
  }
  return grid;
}




function enableSound() {
  ["hitSound","missSound","winSound","turnSound"].forEach(id => {
    const a = document.getElementById(id);
    if (!a) return;
    a.muted = false;
    a.volume = 1;
    a.currentTime = 0;
    a.play().then(() => {
      a.pause();
      a.currentTime = 0;
    });
  });
  alert("Sound enabled!");
}

</script>

<audio id="hitSound" preload="auto">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-explosion-2759.mp3" type="audio/mpeg">
</audio>

<audio id="missSound" preload="auto">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-click-error-1110.mp3" type="audio/mpeg">
</audio>

<audio id="winSound" preload="auto">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
</audio>

<audio id="turnSound" preload="auto">
  <source src="https://assets.mixkit.co/sfx/preview/mixkit-interface-click-1126.mp3" type="audio/mpeg">
</audio>



</body>
</html>
